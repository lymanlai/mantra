# 核心组件

以下是Mantra的核心组件及其结构：

## 聚焦客户端

Mantra特别关注你的应用的 **客户端** 。Mantra没有把客户端和服务端代码混合在一起，而是推荐代码共享。原因如下：

* 客户端是你花费大量精力的地方。他是你代码基础的最大组成部分。服务端代码的管理和组织则相对简单。
* 将来，客户端应用将通过一个协议与服务器端代码交互。客户端应用将无所谓服务器端代码是如何实现的。
* Mantra [不相信万能应用](https://voice.kadira.io/say-no-to-isomorphic-apps-b7b7c419c634#.hogcs5r24)。其鼓励多个应用对应多个平台同时代码共享。届时单服务端对应数个客户端应用会很普遍。

基于以上原因，将客户端和服务器端代码混合则是个不好的模式。

**当我们接下来在本规范讨论Mantra，其实是讨论你的应用的客户端。**

当然，大多数应用有服务端组件。因此我们也给服务端提供了目录结构。参考[附录 B](#sec-Appendix-Server-Side-Directory-Layout)了解详情。

## ES2015语法及模块

我们依赖于ES2015多个特性及其模块系统。为了使用Mantra，你需要使用已经实现了ES2015模块系统的[Meteor 1.3](https://forums.meteor.com/t/meteor-1-3-early-beta-now-available/14723)。

## React作为UI

我们使用React作为UI (展现)层。

在创建UI组件时，你应该通过props传入所有数据及事件处理回调。

注意：你应该在组件内处理React的states，并且不应该与你的应用的其他部分有交互。因此，Mantra强烈建议避免使用states。

在写UI组件时，你可以引进其他React组件。以下为你可以引进React组件的几个地方：

* 你应用内定义的其他UI组件。
* 来自NPM的其他UI组件 (比如 material-ui)。
* 你应用内的任何容器 (我们马上会介绍什么是容器)。

你也可以引进任何第三方库函数并在UI组件中使用。你可以直接从NPM模块引进，但是不要通过Meteor包引入。这些函数得是[纯粹的](https://en.wikipedia.org/wiki/Pure_function)。

这是个简单的UI组件：

```html
import React from 'react';

const PostList = ({posts}) => (
  <div className='postlist'>
    <ul>
      {posts.map(post => (
        <li key={post._id}>
          <a href={`/post/${post._id}`}>{post.title}</a>
        </li>
      ))}
    </ul>
  </div>
);

export default PostList;
```

## Actions

Actions是应用中写 **业务逻辑** 的地方。其包含：

* 验证
* State管理
* 与远程数据源交互

一个action是一个简单的函数，其第一个参数为你的应用的全部[Context](#sec-Application-Context)。其他参数通常在action被调用时一并传递。

注意：在一个action中，所有你做的事情应该基于应用Context及其他你传递来的参数。你不应该引进ES2015模块除了[libraries](#sec-Libraries)。你也应该避免在actions里使用全局变量。

这里是一些actions范例：

```js
export default {
  create({Meteor, LocalState, FlowRouter}, title, content) {
    if (!title || !content) {
      return LocalState.set('SAVING_ERROR', 'Title & Content are required!');
    }

    LocalState.set('SAVING_ERROR', null);

    const id = Meteor.uuid();
    // There is a method stub for this in the config/method_stubs
    // That's how we are doing latency compensation
    Meteor.call('posts.create', id, title, content, (err) => {
      if (err) {
        return LocalState.set('SAVING_ERROR', err.message);
      }
    });
    FlowRouter.go(`/post/${id}`);
  },

  clearErrors({LocalState}) {
    return LocalState.set('SAVING_ERROR', null);
  }
};
```

## State管理

在一个应用中，我们需要处理不同的states。我们可以将他们分为两大类：

1. Local State - 在客户端的State，将会被远程服务器同步 (例如：错误信息, 验证信息, 当前页面)。
2. Remote State - 这类state通常是从远程服务器获取同步的。

在应用内管理states我们有不同的解决方案，包含：

* Meteor/MiniMongo (Remote State)
* Tracker/ReactiveDict (Local State)
* FlowRouter (Local State)
* Redux (Local State)
* GraphQL (Remote State)
* Falcor (Remote State)

这个领域在JavaScript社区的革新非常大。因此Mantra对于state管理非常灵活。你可以使用任意方案。

例如，你可以在应用开发最初阶段用这些方案：

* Meteor/MiniMongo (Remote State)
* Tracker/ReactiveDict (Local State)
* FlowRouter (Local State)

之后你可以迁移到不同解决方案。

注意：尽管如此，Mantra在管理states时强制一些规则。

* 任何写操作必须在action内完成。
* 你可以在actions和containers内读取states。
* 你不应该直接在UI组件内读或者写states。在你的应用中，UI组件不应该知道任何states。

以下为一些states的使用范例：

* [在container内读取本地state](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/newpost.js#L6)
* [在action内写入本地state](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/actions/posts.js#L4)
* [在container内读取远程state](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/postlist.js#L7)

## Containers

在Mantra里，Containers是集成层。他负责这些事物：

* 传递states到UI组件内。
* 传递actions到UI组件内。
* 传递应用Context条目到UI组件内。

一个container是一个React组件。

Containers通过[react-komposer](https://github.com/kadirahq/react-komposer)组合的。其支持不同的数据源，包括Meteor/Tracker, Promises, Rx.js Observable及几乎所有其他的数据源。

通常情况下，在一个container内你需要写这些功能：

* 从state管理器获取数据的组装函数。
* 映射函数以从依赖注入层获得数据。

在创建container时我们有一些规则：

* 在一个文件中只能有一个container并且该container需要作为默认的export。
* 组装函数及映射函数应该在container模块被export出
* 组装函数应该只使用通过props传递来的变量
* 映射函数应该得是[纯粹的](https://en.wikipedia.org/wiki/Pure_function).

注意：如果你需要传递应用Context到一个组件中，请用映射props的方法。

以下是一个container范例：

```js
import PostList from '../components/postlist.jsx';
import {useDeps, composeWithTracker, composeAll} from 'mantra-core';

export const composer = ({context}, onData) => {
  const {Meteor, Collections} = context();
  if (Meteor.subscribe('posts.list').ready()) {
    const posts = Collections.Posts.find().fetch();
    onData(null, {posts});
  }
};

export default composeAll(
  composeWithTracker(composer),
  useDeps()
)(PostList);
```

## 应用Context

应用Context在所有actions和containers中都是可以获得的，因此这是你的app里可以共享变量的地方。其中包括：

* Meteor 命名空间
* Meteor 集合
* LocalState
* FlowRouter
* 其他Meteor包
* Redux Stores
* Rest Clients
* DDP Clients

以下是一个应用Context范例：

```js
import * as Collections from '/lib/collections';
import {Meteor} from 'meteor/meteor';
import {FlowRouter} from 'meteor/kadira:flow-router';
import {ReactiveDict} from 'meteor/reactive-dict';
import {Tracker} from 'meteor/tracker';

export default function () {
  return {
    Meteor,
    FlowRouter,
    Collections,
    LocalState: new ReactiveDict(),
    Tracker
  };
}
```

## 依赖注入

Mantra使用依赖注入来分隔你的应用的不同部分，包括UI组件及actions。

我们用一个叫做[`react-simple-di`](https://github.com/kadirahq/react-simple-di)的项目来使用React的上下文。 其接受[应用 Context](#sec-Application-Context) 和 [Actions](#sec-Actions)作为依赖参数。

一旦设置好，应用Context将会被注入到每个action。其为action的第一个参数。因此你不需要手动传递应用context。

应用Context也可以在[Containers](#sec-Containers)内访问到。

### 配置依赖注入

依赖江北注入到你的应用的顶层组件中。通常会是个Layout组件。你可以在你的路由中做这个注入，参考范例：

```js
import React from 'react';
export default function (injectDeps) {
  // See: Injecting Deps
  const MainLayoutCtx = injectDeps(MainLayout);

  // Routes related code
}
```

## 路由和组件挂载

注意：当我们提到组件，我们意思包括containers和UI组件。

我们通常用路由来挂载组件到UI上。这有多种方案（例如，[Flow Router](https://github.com/kadirahq/flow-router/) 及 [React Router](https://github.com/rackt/react-router)）。

在Mantra中路由的唯一作用是挂载组件到UI上。他只是个工具而已。

以下为使用FlowRouter作为路由的范例：

```js
import React from 'react';
import {FlowRouter} from 'meteor/kadira:flow-router';
import {mount} from 'react-mounter';

import MainLayout from '/client/modules/core/components/layout.main.jsx';
import PostList from '/client/modules/core/containers/postlist';

export default function (injectDeps) {
  const MainLayoutCtx = injectDeps(MainLayout);

  FlowRouter.route('/', {
    name: 'posts.list',
    action() {
      mount(MainLayoutCtx, {
        content: () => (<PostList />)
      });
    }
  });
}
```

注意：如果你需要在某些情况下（例如用户未授权）重定向，则使用action代替类似FlowRouter的triggersEnter参数。在组件或者container的组装函数调用action。


## 库

每个应用都有一些工具函数来完成不同的任务。你也可以通过NPM获得他们。这些库将会导出函数。因此你可以在你应用的任何地方（包括actions内、组件及containers）导入他们。

> 当在组件内用函数库时，其应该是[纯粹的](https://en.wikipedia.org/wiki/Pure_function)。

## 测试

测试是Mantra的一个核心部分。Mantra帮助你测试应用的各个部分。我们强制的规则将帮助你写那些测试。你可以用熟悉的工具如[Mocha](https://mochajs.org/)、[Chai](http://chaijs.com/)及 [Sinon](http://sinonjs.org/)来执行测试。

在Mantra，你可以单元测试应用的三个核心部分：

* UI组件 - [范例](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js)
* Actions - [范例](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/actions/tests/posts.js)
* Container组装器及依赖映射器 - [范例](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/tests/post.js)

### UI测试

UI测试我们用[enzyme](https://github.com/airbnb/enzyme). 点击[这里](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js)查看测试案例。

## Mantra 模块

Mantra遵循一个模块化架构。所有的Mantra组件除了["应用Context"](#sec-Application-Context)应该在模块内。

你可以创建尽可能多的模块并通过imports来互相连通

### 应用Context与模块

[应用Context](#sec-Application-Context)是应用程序的核心。其需要定义在某个不属于任何模块的地方。所有的模块可以访问应用Context作为依赖并且模块不应该改变应用Context。

### 模块定义

Mantra模块可以有一个定义文件。其暴露actions、路由及一个接受context的函数。他是模块的`index.js`文件。

一个简单的模块定义类似这样：

```js
export default {
  // optional
  load(context, actions) {
    // do any module initialization
  },
  // optional
  actions: {
    myNamespace: {
      doSomething: (context, arg1) => {}
    }
  },
  // optional
  routes(injectDeps) {
    const InjectedComp = injectDeps(MyComp);
    // load routes and put `InjectedComp` to the screen.
  }
};
```

### 潜在模块

如果该模块没有actions和routes或者不需要任何初始化，则我们可以不需要一个定义文件。这些潜在模块可能包括：

* UI组件
* Containers
* Libraries

### 模块Containers 与UI 组件

模块 containers 与 UI 组件要能通过 ES2015 modules 引入。

### 模块 Actions

模块可以通过命名空间暴露actions。这些命名空间在app内是全局的，因此模块需要保证其命名不冲突。模块可以暴露多个命名空间。

最终，所有模块的命名空间被合并并且可以在actions和containers内访问。

### 路由

你可以用任意的路由库。可以在多个模块内都有路由定义。

### 核心模块

Mantra是100%模块化并且在一个app内至少需要一个模块。我们把这个必须的模块叫核心模块。该模块在所有其他模块加载前加载。该模块内最合适放：

* 核心路由
* 应用配置
* 共享库
* 共享actions

及其他应用特定的代码。

根据app需求有多种方式组织模块。参考[附录 C](#sec-Appendix-Organizing-Modules)查看更多范例。

### 子模块

在模块内，你 **不能** 有子模块。这个决定是为了防止不必要的复杂性。否则，有可能写多层级的嵌套模块，这会非常难以管理。

## 单入口

Mantra内，我们希望我们的app可预测。因此在你的app内有一个单入口文件，`client/main.js`。

其将初始化应用程序Context并加载你的应用内的所有模块。这里是一个`client/main.js`文件范例： 

```js
import {createApp} from 'mantra-core';
import {initContext} from './configs/context';

// modules
import coreModule from './modules/core';
import commentsModule from './modules/comments';

// init context
const context = initContext();

// create app
const app = createApp(context);
app.loadModule(coreModule);
app.loadModule(commentsModule);
app.init();
```
